"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInteractive = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./constants");
const inquire_1 = require("./inquire");
const runCheck_1 = require("./runCheck");
const runList_1 = require("./runList");
const runUpdate_1 = require("./runUpdate");
const urlUtils_1 = require("./urlUtils");
function logWorkflowChecks(resources, args) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all(resources.map(resource => resource.getRemote()));
        const checkLists = yield Promise.all(resources.map(resource => runCheck_1.runCheck(resource, args.force, args.clean)));
        const result = [];
        resources.forEach((resource, index) => {
            const checks = checkLists[index];
            result.push([resource, checks]);
            if (resource.existsLocally()) {
                console.log(resource.getTitle());
                checks.forEach(check => runCheck_1.logCheck(check, args.force, args.diff));
                runCheck_1.logCheck(runCheck_1.getCheckResult(resource, checks, args.force));
            }
            else {
                runList_1.runList(resource, resource.getRemoteCached());
            }
        });
        return result;
    });
}
function logWorkflowUpdates(resource, checks, forceUpdate) {
    console.log(resource.getTitle());
    runUpdate_1.logUpdate(runCheck_1.getCheckResult(resource, checks, forceUpdate));
}
function checkLocalPath(localPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (fs_1.default.existsSync(localPath))
            return true;
        console.log(`Let's set up some ${chalk_1.default.bold("GitHub Actions")} for this project!\n`);
        if (!(yield inquire_1.createWorkflowsDir(localPath))) {
            console.log("Okay, looks like that was a wrong directory.");
            console.log(`Restart me where I should be, or just use ${chalk_1.default.blue("--path <github repo path>")}`);
            console.log("Bye for now!");
            return false;
        }
        fs_1.default.mkdirSync(localPath, { recursive: true });
        console.log(`Awesome, we have just created ${chalk_1.default.bold(localPath)} directory!\n`);
        return true;
    });
}
function runInteractive(args) {
    return __awaiter(this, void 0, void 0, function* () {
        console.clear();
        console.log("Hi there!\n");
        console.log(`I am ${chalk_1.default.bold(chalk_1.default.blue("GitHub Actions Manager"))}, as you probably know already.\n`);
        const localPath = path_1.default.join(args.path, constants_1.LOCAL_WORKFLOWS_PATH);
        if (!(yield checkLocalPath(localPath))) {
            return;
        }
        const workflowIndex = yield inquire_1.chooseIndex(args.index, args.ref, localPath);
        if (!workflowIndex.names.length) {
            console.log(`No workflows found in ${workflowIndex.url}`);
            return;
        }
        console.log(`Using index ${urlUtils_1.highlightURL(workflowIndex.url)}`);
        const resources = yield inquire_1.selectWorkflows(workflowIndex);
        if (args.list) {
            yield runList_1.runListAll(resources);
            return;
        }
        while (true) {
            const resourceCheckLists = yield logWorkflowChecks(resources, args);
            const changedResourceChecks = resourceCheckLists.filter(([resource, checks]) => !resource.existsLocally() ||
                checks.filter(check => check.isApplied(args.force)).length);
            const forceChangedResourceChecks = resourceCheckLists.filter(([resource, checks]) => !resource.existsLocally() ||
                checks.filter(check => check.isApplied(true)).length);
            const changedResources = changedResourceChecks.map(([resource]) => resource);
            const confirmResult = yield inquire_1.confirmRerunApply(args.force, args.diff, changedResourceChecks.length > 0, forceChangedResourceChecks.length > 0);
            if (confirmResult === "discard") {
                console.log("");
                console.log("Okay, let's keep things as they are...");
                break;
            }
            if (confirmResult === "apply") {
                changedResourceChecks.map(([resource, checks]) => logWorkflowUpdates(resource, checks, args.force));
                yield Promise.all(changedResources.map(resource => runUpdate_1.runUpdate(resource, args.force, args.clean)));
                break;
            }
            if (confirmResult === "rerun_force")
                args.force = true;
            if (confirmResult === "rerun_noforce")
                args.force = false;
            if (confirmResult === "rerun_diff")
                args.diff = true;
            if (confirmResult === "rerun_nodiff")
                args.diff = false;
        }
        console.log("");
        console.log("My job here is done! Start me from time to time to sync up changes. Bye for now!");
    });
}
exports.runInteractive = runInteractive;
