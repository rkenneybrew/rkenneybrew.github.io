"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const cli_1 = require("./cli");
const constants_1 = require("./constants");
const indexes_1 = require("./indexes");
const runCheck_1 = require("./runCheck");
const runInteractive_1 = require("./runInteractive");
const runList_1 = require("./runList");
const runUpdate_1 = require("./runUpdate");
const urlUtils_1 = require("./urlUtils");
const utils_1 = require("./utils");
const workflowIndex_1 = require("./workflow/workflowIndex");
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        let args;
        const commandName = utils_1.getCommandName();
        try {
            args = cli_1.parseArgs();
        }
        catch (e) {
            console.log(e.message);
            console.log("Use `--help` to know more");
            process.exit(1);
        }
        if (args.help) {
            console.log(cli_1.getHelp());
            process.exit(0);
        }
        if (args.version) {
            console.log(utils_1.getVersionString());
            process.exit(0);
        }
        if (args.names.length === 0) {
            try {
                yield runInteractive_1.runInteractive(args);
            }
            catch (e) {
                console.warn(chalk_1.default.red(`✗  ${e}`));
                process.exit(1);
            }
            process.exit(0);
        }
        if (!fs_1.default.existsSync(args.path)) {
            console.warn(chalk_1.default.red(`✗  ${chalk_1.default.bold(args.path)} directory does not exist`));
            console.warn(chalk_1.default.yellow("✎  Probably this is not a GitHub repository root"));
            console.warn(chalk_1.default.yellow(`✎  If it is, create this directory with: ${chalk_1.default.bold(`mkdir -p ${args.path}`)}`));
            process.exit(1);
        }
        let workflowIndex;
        let workflows;
        try {
            workflowIndex = yield workflowIndex_1.WorkflowIndex.fromURL(urlUtils_1.replaceRef(args.index || indexes_1.JS_INDEX_URL, args.ref), path_1.default.join(args.path, constants_1.LOCAL_WORKFLOWS_PATH));
            console.log(`Using index ${urlUtils_1.highlightURL(workflowIndex.url)}`);
            workflows = workflowIndex.getWorkflows(args.names);
        }
        catch (e) {
            console.log(chalk_1.default.red(`✗  ${e.message}`));
            process.exit(1);
        }
        if (workflows.length === 0) {
            const commandList = `${utils_1.getCommandName()} --list`;
            console.log(`✎  No workflows found, install them first, or check ${chalk_1.default.bold(commandList)}`);
            const command = `${utils_1.getCommandName()} -u all`;
            console.log(`${chalk_1.default.bold(chalk_1.default.blue(command))} ${chalk_1.default.grey("// install all workflows below")}`);
            workflowIndex.getAllWorkflows().map(workflow => {
                const command = `${utils_1.getCommandName()} -u ${workflow.name}`;
                const description = workflow.title
                    ? `// install to ${utils_1.decapitalize(workflow.title)}`
                    : "";
                console.log(`${chalk_1.default.bold(chalk_1.default.blue(command))} ${chalk_1.default.grey(description)}`);
            });
            process.exit(0);
        }
        if (args.list) {
            runList_1.runListAll(workflows);
            process.exit(0);
        }
        if (!args.update) {
            const result = yield runCheck_1.runCheckAll(workflows, args.force, args.diff, args.clean);
            if (result) {
                console.log(chalk_1.default.green(`✓  Run ${chalk_1.default.bold(`${commandName} ${utils_1.getCommandArgs()} --update`)} any time you want!`));
            }
            else
                logUpdateError();
            process.exit(result ? 0 : 1);
        }
        yield runUpdate_1.runUpdateAll(workflows, args.force, args.diff, args.clean);
    });
}
function logUpdateError() {
    console.log(chalk_1.default.red("✗  Found errors that prevent update"));
    console.log(chalk_1.default.grey("✎  Delete invalid workflows, update all, and merge your changes"));
    console.log(chalk_1.default.grey(`✎  Check for updates: ${constants_1.DOCS_URL}`));
}
if (typeof require !== "undefined" && require.main === module) {
    main();
}
exports.default = main;
