"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceRef = exports.highlightURL = exports.isFileURL = exports.isGitHubURL = exports.joinURL = exports.download = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
const util_1 = require("util");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
function download(url) {
    return __awaiter(this, void 0, void 0, function* () {
        const parsedUrl = new url_1.URL(url);
        if (parsedUrl.protocol === "file:") {
            return util_1.promisify(fs_1.default.readFile)(url_1.fileURLToPath(url), { encoding: constants_1.UTF8 });
        }
        const tempPath = utils_1.getTempDir();
        const dest = path_1.default.join(tempPath, path_1.default.basename(url));
        const file = fs_1.default.createWriteStream(dest);
        const getFunc = parsedUrl.protocol === "https:" ? https_1.default.get : http_1.default.get;
        return new Promise((resolve, reject) => {
            const request = getFunc(url, function (response) {
                response.pipe(file);
            });
            file.on("finish", function () {
                file.close();
                resolve(fs_1.default.readFileSync(dest, { encoding: constants_1.UTF8 }));
                fs_1.default.rmdirSync(tempPath, { recursive: true });
            });
            request.on("error", function (err) {
                fs_1.default.rmdirSync(tempPath, { recursive: true });
                reject(err);
            });
            file.on("error", err => {
                fs_1.default.rmdirSync(tempPath, { recursive: true });
                reject(err);
            });
        });
    });
}
exports.download = download;
function joinURL(base, newPath) {
    const url = new url_1.URL(base);
    let oldPathname = url.pathname;
    const origin = base.substr(0, base.length - url.pathname.length);
    if (!base.endsWith("/"))
        oldPathname = path_1.default.dirname(oldPathname);
    const pathname = path_1.default.join(oldPathname, newPath);
    return `${origin}${pathname}`;
}
exports.joinURL = joinURL;
function isGitHubURL(url) {
    try {
        const hostname = new url_1.URL(url).hostname;
        return hostname === "github.com" || hostname.endsWith(".github.com");
    }
    catch (_a) {
        return false;
    }
}
exports.isGitHubURL = isGitHubURL;
function isFileURL(url) {
    try {
        return new url_1.URL(url).protocol === "file:";
    }
    catch (_a) {
        return false;
    }
}
exports.isFileURL = isFileURL;
function highlightURL(url) {
    if (isGitHubURL(url)) {
        const parsedURL = new url_1.URL(url);
        const [, owner, repo, tree, ref, ...directories] = parsedURL.pathname.split("/");
        return `${chalk_1.default.grey(parsedURL.origin)}/${chalk_1.default.blue(owner)}/${chalk_1.default.blue(repo)}/${chalk_1.default.grey(tree)}/${chalk_1.default.grey(ref)}/${directories.join("/")}`;
    }
    if (isFileURL(url)) {
        const parsedURL = new url_1.URL(url);
        return `${chalk_1.default.grey("file://")}${parsedURL.pathname}`;
    }
    return url;
}
exports.highlightURL = highlightURL;
function replaceRef(url, ref) {
    if (isGitHubURL(url)) {
        const parsedURL = new url_1.URL(url);
        const [, owner, repo, tree, oldRef, ...directories] = parsedURL.pathname.split("/");
        const pathname = directories.join("/") || ".github/workflows";
        parsedURL.pathname = `${owner}/${repo}/${tree || "tree"}/${ref || oldRef || "master"}/${pathname}`;
        return parsedURL.href;
    }
    return url;
}
exports.replaceRef = replaceRef;
