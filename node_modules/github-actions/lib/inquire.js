"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.confirmRerunApply = exports.confirmApply = exports.selectWorkflows = exports.createWorkflowsDir = exports.chooseIndex = void 0;
const chalk_1 = __importDefault(require("chalk"));
const configstore_1 = __importDefault(require("configstore"));
const inquirer_1 = __importDefault(require("inquirer"));
const inquirer_select_directory_1 = __importDefault(require("inquirer-select-directory"));
const url_1 = require("url");
const indexes_1 = require("./indexes");
const urlUtils_1 = require("./urlUtils");
const workflowIndex_1 = require("./workflow/workflowIndex");
function chooseIndex(url, ref, workflowsPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (url) {
            return workflowIndex_1.WorkflowIndex.fromURL(urlUtils_1.replaceRef(url, ref), workflowsPath);
        }
        const defaultIndexes = indexes_1.INDEXES.map(index => index.url);
        const config = new configstore_1.default("github-actions", {
            indexes: defaultIndexes
        });
        const indexes = config.get("indexes");
        indexes.push(...defaultIndexes.filter(index => !indexes.includes(index)));
        const titlePad = 15;
        return inquirer_1.default
            .prompt([
            {
                name: "url",
                type: "list",
                message: "Select project type or choose any repository with workflows",
                pageSize: 30,
                choices: [
                    ...indexes.map(url => {
                        const index = indexes_1.getIndexResource(url);
                        const title = index
                            ? `${index.title.padEnd(titlePad)} ${urlUtils_1.highlightURL(urlUtils_1.replaceRef(url, ref))}`
                            : `${"Recently used".padEnd(titlePad)} ${urlUtils_1.highlightURL(urlUtils_1.replaceRef(url, ref))}`;
                        return {
                            name: title,
                            value: url
                        };
                    }),
                    {
                        name: `${"From GitHub URL".padEnd(titlePad)} ${chalk_1.default.grey("https://github.com/<owner>/<repo>/tree/main/.github/workflows")}`,
                        value: "github"
                    },
                    {
                        name: `${"From directory".padEnd(titlePad)} ${chalk_1.default.grey("other/project/.github/workflows")}`,
                        value: "path"
                    }
                ]
            }
        ])
            .then(({ url }) => __awaiter(this, void 0, void 0, function* () {
            if (url === "github") {
                url = yield inputGitHubURL(ref);
            }
            if (url === "path") {
                let currentPath = ".";
                while (true) {
                    currentPath = yield inputLocalPath(currentPath);
                    url = url_1.pathToFileURL(currentPath).href;
                    const index = yield workflowIndex_1.WorkflowIndex.fromFileURL(url, workflowsPath);
                    if (!index.names.length) {
                        console.log(chalk_1.default.red(`âœ—  Path ${chalk_1.default.bold(currentPath)} does not have workflows, choose ${chalk_1.default.bold(".github/workflows")} directory`));
                        continue;
                    }
                    break;
                }
            }
            const result = yield workflowIndex_1.WorkflowIndex.fromURL(urlUtils_1.replaceRef(url, ref), workflowsPath);
            console.log(`\nNext time you can run me with ${chalk_1.default.blue(`-i ${indexes_1.getShortcut(url) || urlUtils_1.replaceRef(url, ref)}`)}\n`);
            const newIndexes = [
                url,
                ...indexes.filter(index => index !== url)
            ];
            config.set("indexes", newIndexes.slice(0, 30));
            return result;
        }));
    });
}
exports.chooseIndex = chooseIndex;
function inputGitHubURL(ref) {
    return __awaiter(this, void 0, void 0, function* () {
        return inquirer_1.default
            .prompt([
            {
                name: "input",
                type: "input",
                message: `Paste URL to ${chalk_1.default.bold("<github_repo>/.github/workflows")} ${chalk_1.default.grey("e.g. https://github.com/psf/black/tree/master/.github/workflows")}\n : `,
                validate: (value) => __awaiter(this, void 0, void 0, function* () {
                    const index = yield workflowIndex_1.WorkflowIndex.fromURL(urlUtils_1.replaceRef(value, ref), "");
                    if (index.names.length)
                        return true;
                    return `Path ${value} does not have workflows`;
                })
            }
        ])
            .then(({ input }) => input);
    });
}
function inputLocalPath(basePath) {
    return __awaiter(this, void 0, void 0, function* () {
        inquirer_1.default.registerPrompt("directory", inquirer_select_directory_1.default);
        return inquirer_1.default
            .prompt([
            {
                name: "input",
                type: "directory",
                basePath: basePath,
                message: `Select path to ${chalk_1.default.bold(".github/workflows")}`,
                options: {
                    displayHidden: true
                }
            }
        ])
            .then(({ input }) => input);
    });
}
function createWorkflowsDir(path) {
    return __awaiter(this, void 0, void 0, function* () {
        return inquirer_1.default
            .prompt([
            {
                name: "answer",
                type: "confirm",
                message: `It looks like we do not have ${chalk_1.default.blue(path)} directory to store workflows. Create it?`
            }
        ])
            .then(({ answer }) => answer);
    });
}
exports.createWorkflowsDir = createWorkflowsDir;
function selectWorkflows(workflowIndex) {
    return __awaiter(this, void 0, void 0, function* () {
        const hasInstalled = workflowIndex.getInstalledWorkflows().length > 0;
        const names = [
            ...(hasInstalled ? ["installed"] : []),
            "all",
            ...workflowIndex.names
        ];
        const choices = [
            ...(hasInstalled
                ? [
                    ` Installed workflows ${chalk_1.default.green("(green ones)")} ${chalk_1.default.grey("installed")}`
                ]
                : []),
            ` All workflows below ${chalk_1.default.grey("all")}`,
            ...workflowIndex.getAllWorkflows().map(w => {
                const title = w.getTitle(w.existsLocally() ? "is installed to" : "can be installed to", w.existsLocally() ? chalk_1.default.green : chalk_1.default.white);
                return ` ${title}`;
            })
        ];
        const message = hasInstalled
            ? "Select workflows to install or update"
            : "Select workflows to install";
        return inquirer_1.default
            .prompt([
            {
                name: "names",
                type: "checkbox",
                default: hasInstalled ? ["installed"] : [],
                message: message,
                validate: result => {
                    if (result.length)
                        return true;
                    return "Select at least one workflow";
                },
                pageSize: 30,
                choices: choices.map(choice => ({
                    name: choice,
                    value: names[choices.indexOf(choice)]
                }))
            }
        ])
            .then(({ names }) => {
            return workflowIndex.getWorkflows(names);
        });
    });
}
exports.selectWorkflows = selectWorkflows;
function confirmApply() {
    return __awaiter(this, void 0, void 0, function* () {
        return inquirer_1.default
            .prompt([
            {
                name: "confirm",
                type: "confirm",
                message: `Apply updates?`
            }
        ])
            .then(({ confirm }) => confirm);
    });
}
exports.confirmApply = confirmApply;
function confirmRerunApply(forceUpdate, showDiff, hasChanges, hasForceChanges) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!hasForceChanges)
            return "apply";
        const choices = [];
        if (hasChanges) {
            choices.push({
                name: `${chalk_1.default.green("Apply")} listed changes and exit`,
                value: "apply"
            });
        }
        else {
            choices.push({
                name: `Exit, as everything is ${chalk_1.default.green("up to date")}`,
                value: "apply"
            });
        }
        if (forceUpdate) {
            choices.push({
                name: `Remove ${chalk_1.default.blue("--force")} flag to keep user-edited parts untouched`,
                value: "rerun_noforce"
            });
        }
        else {
            choices.push({
                name: `Add ${chalk_1.default.blue("--force")} flag to update user-edited parts`,
                value: "rerun_force"
            });
        }
        if (showDiff) {
            choices.push({
                name: `Hide changed lines, disable ${chalk_1.default.blue("--diff")} flag`,
                value: "rerun_nodiff"
            });
        }
        else {
            choices.push({
                name: `Show changed lines with ${chalk_1.default.blue("--diff")} flag`,
                value: "rerun_diff"
            });
        }
        if (hasChanges) {
            choices.push({ name: "Discard changes and exit", value: "discard" });
        }
        return inquirer_1.default
            .prompt([
            {
                name: "result",
                type: "list",
                message: "What do we do next?",
                choices: choices
            }
        ])
            .then(({ result }) => result);
    });
}
exports.confirmRerunApply = confirmRerunApply;
