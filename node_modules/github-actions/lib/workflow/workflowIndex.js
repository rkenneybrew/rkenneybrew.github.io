"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowIndex = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const url_1 = require("url");
const constants_1 = require("./../constants");
const github_1 = require("./../github");
const urlUtils_1 = require("./../urlUtils");
const resource_1 = require("./resource");
class WorkflowIndex {
    constructor(url, workflowsPath, workflowURLs) {
        this.url = url;
        this.name = url;
        this.workflowsPath = workflowsPath;
        this._workflows = workflowURLs.map(url => new resource_1.WorkflowResource(url, this.workflowsPath));
        this.names = this._workflows.map(w => w.name);
        this.shortcut = "";
    }
    getWorkflow(name) {
        const workflow = this._workflows.find(w => w.name === name);
        if (!workflow)
            throw new Error(`Workflow ${name} does not exist in index`);
        return workflow;
    }
    getAllWorkflows() {
        return this.names.map(name => this.getWorkflow(name));
    }
    getInstalledWorkflows() {
        return this.getAllWorkflows().filter(workflow => workflow.existsLocally());
    }
    getWorkflows(names) {
        const result = [];
        names.forEach(name => {
            const workflows = {
                all: this.getAllWorkflows(),
                installed: this.getInstalledWorkflows()
            }[name] || [this.getWorkflow(name)];
            result.push(...workflows.filter(w => !result.map(x => x.name).includes(w.name)));
        });
        return result;
    }
    static fromURL(url, workflowsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (urlUtils_1.isFileURL(url))
                return WorkflowIndex.fromFileURL(url, workflowsPath);
            if (urlUtils_1.isGitHubURL(url))
                return WorkflowIndex.fromGitHubURL(url, workflowsPath);
            throw new Error(`URL ${url} is not supported, provide https://github.com URL or file url`);
        });
    }
    static fromGitHubURL(url, workflowsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const workflowURLs = (yield github_1.listWorkflowURLs(url)).filter(url => constants_1.EXTENSIONS.includes(path_1.default.parse(url).ext));
            const result = new WorkflowIndex(url, workflowsPath, workflowURLs);
            return result;
        });
    }
    static fromFileURL(url, workflowsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootPath = url_1.fileURLToPath(url);
            const files = fs_1.default.readdirSync(rootPath);
            const workflows = files
                .filter(filePath => constants_1.EXTENSIONS.includes(path_1.default.parse(filePath).ext))
                .map(filePath => url_1.pathToFileURL(path_1.default.join(rootPath, filePath)).href);
            return new WorkflowIndex(url, workflowsPath, workflows);
        });
    }
}
exports.WorkflowIndex = WorkflowIndex;
