"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Checker = void 0;
const deep_equal_1 = __importDefault(require("deep-equal"));
const check_1 = require("./check");
const step_1 = require("./step");
class Checker {
    constructor(force, current) {
        this.force = force;
        this.current = current;
    }
    getChecks(update) {
        const errors = this.getErrors();
        if (errors.length)
            return errors;
        return [
            ...this.getWorkflowChecks(update),
            ...this.getJobsChecks(update)
        ];
    }
    getStepErrors(currentJob) {
        const stepIds = new Set();
        const result = [];
        currentJob.steps.forEach(step => {
            if (!step.id)
                return;
            if (stepIds.has(step.id))
                result.push(`${step.name} step has duplicate id ${step.id}`);
        });
        return result;
    }
    getErrors() {
        const result = [];
        this.current.jobs.forEach(job => {
            this.getStepErrors(job).map(error => new check_1.Check("error", "error", false, error));
        });
        return result;
    }
    static getAction(oldValue, newValue) {
        if (deep_equal_1.default(oldValue, newValue))
            return "equal";
        if (!oldValue)
            return "added";
        if (!newValue)
            return "deleted";
        return "updated";
    }
    getWorkflowChecks(update) {
        return [
            new check_1.Check("top comment", Checker.getAction(this.current.commentLines, update.commentLines), true, this.current.commentLines.join("\n"), update.commentLines.join("\n")),
            new check_1.Check("workflow name", Checker.getAction(this.current.name, update.name), true, this.current.name, update.name),
            new check_1.Check("trigger", Checker.getAction(this.current.triggers, update.triggers), true, this.current.triggers, update.triggers)
        ];
    }
    getJobsChecks(update) {
        const result = [];
        update.jobNames.forEach(jobName => {
            const updateJob = update.getJob(jobName);
            if (!this.current.jobNames.includes(jobName)) {
                result.push(new check_1.Check("job", "added", false, null, updateJob));
                return;
            }
            const currentJob = this.current.getJob(jobName);
            result.push(...this.getJobChecks(currentJob, updateJob));
        });
        this.current.jobNames
            .filter(jobName => !update.jobNames.includes(jobName))
            .map(jobName => {
            const currentJob = this.current.getJob(jobName);
            result.push(new check_1.Check("job", "deleted", true, currentJob, null));
        });
        return result;
    }
    getJobChecks(currentJob, updateJob) {
        return [
            new check_1.Check("job environment", Checker.getAction(currentJob.env, updateJob.env), true, currentJob.env, updateJob.env),
            new check_1.Check("job runner", Checker.getAction(currentJob.runsOn, updateJob.runsOn), true, currentJob.runsOn, updateJob.runsOn),
            new check_1.Check("job strategy", Checker.getAction(currentJob.strategy, updateJob.strategy), true, currentJob.strategy, updateJob.strategy),
            new check_1.Check("job run condition", Checker.getAction(currentJob.runsIf, updateJob.runsIf), true, currentJob.runsIf, updateJob.runsIf),
            ...this.getStepChecks(currentJob, updateJob)
        ];
    }
    getStepChecks(currentJob, updateJob) {
        const currentSteps = currentJob.steps;
        const updateSteps = updateJob.steps;
        return [
            ...currentSteps
                .filter(step => step.findIndex(updateSteps) < 0)
                .map(step => new check_1.Check("step", "deleted", false, step)),
            ...updateSteps.map(step => {
                const stepIndex = step.findIndex(currentSteps);
                const localStep = currentSteps[stepIndex] || new step_1.Step({});
                return new check_1.Check("step", (() => {
                    if (stepIndex < 0)
                        return "added";
                    if (!localStep.isManaged())
                        return "kept";
                    if (localStep.equals(step))
                        return "equal";
                    return "updated";
                })(), false, localStep, step);
            })
        ];
    }
}
exports.Checker = Checker;
