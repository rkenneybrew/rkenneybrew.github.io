"use strict";
const p2p_errors = require("./p2p.errors.js");
/**
 * @template {AnyCallableFunction} T
 *
 * @param {T} callable
 * @return {PromiseWrappedFunction<T>}
 */
function promise(callable) {
  return (...parameters) => {
    try {
      const result = callable(...parameters);
      if (result instanceof Promise) return result;
      return Promise.resolve(result);
    } catch (error) {
      return Promise.reject(error);
    }
  };
}
/**
 *
 *
 * @template T
 * @param {Request} request
 * @return {Promise<T>} Promise<T>
 */
async function parseJsonRequestBody(request) {
  if (typeof request.body === "object" && request.body) {
    return request.body;
  }
  return new Promise((resolve, reject) => {
    let body = "";
    request.on("error", (error) => reject(error));
    request.on("data", (chunk) => {
      body += chunk.toString();
    });
    request.on("end", () => {
      const data = JSON.parse(body.toString());
      resolve(data);
    });
  });
}
const skipMiddleware = (_request, _response, next) => next();
/**
 *
 *
 * @param {(string | string[] | undefined)} value
 * @return {string} string
 */
function resolveHeaderValue(value) {
  if (!value) return "";
  if (Array.isArray(value)) return resolveHeaderValue(value[0]);
  return value;
}
/**
 *
 *
 * @export
 * @param {P2pBillsApi} bills
 * @param {MiddlewareOptions} [options={}]
 * @param {BillRequestHandler} [handler]
 * @return {BillRequestHandler} BillRequestHandler
 */
function createP2pNotificationMiddleware(
  bills,
  options = {},
  handler = skipMiddleware
) {
  const calls = new Map();
  const { memo = true, memoTime = 1000 * 60 * 15 } = options;
  return async function p2pNotificationMiddleware(request, response, next) {
    const notification = await parseJsonRequestBody(request);
    const signature = resolveHeaderValue(request.headers["x-api-signature-sha256"]);
    if (memo && calls.has(signature)) return next();
    const { bill } = notification;
    if (!bills.checkNotificationSignature(signature, notification)) {
      return next(new p2p_errors.P2pBillNotificationError(bill));
    }
    request.body = bill;
    if (!memo) return handler(request, response, next);
    await promise(handler)(request, response, next);
    calls.set(signature, Date.now());
    for (const [signature, time] of calls) {
      if (Date.now() - memoTime > time) calls.delete(signature);
    }
  };
}
exports.createP2pNotificationMiddleware = createP2pNotificationMiddleware;
exports.parseJsonRequestBody = parseJsonRequestBody;
exports.promise = promise;
exports.resolveHeaderValue = resolveHeaderValue;
