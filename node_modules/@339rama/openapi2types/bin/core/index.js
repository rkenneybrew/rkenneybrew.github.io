'use strict';
var __assign =
  (this && this.__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign.apply(this, arguments);
  };
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.parseV3types = exports.parseV2types = void 0;
var chalk_1 = __importDefault(require('chalk'));
var utils_1 = require('../utils');
var parseRefName = function (value) {
  return (0, utils_1.capitalize)(
    (value === null || value === void 0 ? void 0 : value.split('/').reverse()[0]) || '',
  );
};
var parseOpenApiPropertyType = function (property) {
  var parsedTypes = [];
  switch (property.type) {
    case 'string':
      parsedTypes.push('string');
      break;
    case 'integer':
      parsedTypes.push('number');
      break;
    case 'array':
      parsedTypes.push(''.concat(parseRefName(property.items.$ref), '[]'));
      break;
    default:
      parsedTypes.push('unknown');
      break;
  }
  if (property.nullable) {
    parsedTypes.push('null');
  }
  return parsedTypes.join(' | ');
};
var writeProperties = function (stream, properties, required) {
  for (var property in properties) {
    var hasComment = properties[property].description || properties[property].format;
    var isRequired =
      (required === null || required === void 0 ? void 0 : required.includes(property)) ||
      !(required === null || required === void 0 ? void 0 : required.length);
    var isRef = properties[property].$ref;
    if (hasComment) {
      stream.write('\t//');
    }
    if (properties[property].format) {
      stream.write(' ['.concat(properties[property].format, ']'));
    }
    if (properties[property].description) {
      stream.write(' '.concat(properties[property].description));
    }
    if (hasComment) {
      stream.write('\n');
    }
    stream.write('\t');
    if (properties[property].readOnly) {
      stream.write('readonly ');
    }
    stream.write(property);
    if (isRequired) {
      stream.write(': ');
    } else {
      stream.write('?: ');
    }
    if (isRef) {
      stream.write(parseRefName(properties[property].$ref));
    } else {
      stream.write(parseOpenApiPropertyType(properties[property]));
    }
    stream.write(';\n');
  }
};
var prepareDefinitionWithAllOf = function (definition, definitions) {
  var _a;
  if (!((_a = definitions[definition]) === null || _a === void 0 ? void 0 : _a.properties)) {
    definitions[definition].properties = {};
  }
  var allOf = definitions[definition].allOf;
  var extendTypes = [];
  if (allOf) {
    for (var _i = 0, allOf_1 = allOf; _i < allOf_1.length; _i++) {
      var part = allOf_1[_i];
      if (part.$ref) {
        var definitionKey = parseRefName(part.$ref);
        extendTypes.push(definitionKey);
      }
      if (part.properties) {
        definitions[definition].properties = __assign(
          __assign({}, definitions[definition].properties),
          part.properties,
        );
      }
    }
  }
  if (extendTypes.length) {
    extendTypes.push('');
  }
  return { extendTypes: extendTypes.join(' & ') };
};
var writeArrayType = function (stream, definition, definitions) {
  var _a;
  var ref = (_a = definitions[definition].items) === null || _a === void 0 ? void 0 : _a.$ref;
  if (ref) {
    stream.write('export type '.concat(definition, ' = ').concat(parseRefName(ref), '[]\n\n'));
  }
};
var writeObjectType = function (stream, definition, definitions) {
  var extendTypes = prepareDefinitionWithAllOf(definition, definitions).extendTypes;
  var properties = definitions[definition].properties;
  if (properties && Object.keys(properties).length) {
    stream.write(
      'export type '.concat((0, utils_1.capitalize)(definition), ' = ').concat(extendTypes, '{\n'),
    );
    writeProperties(stream, properties, definitions[definition].required);
    stream.write('}\n\n');
  }
};
var writeType = function (stream, definition, definitions) {
  if (definitions[definition].type === 'array') {
    return writeArrayType(stream, definition, definitions);
  }
  return writeObjectType(stream, definition, definitions);
};
var parseV2types = function (schema, writeStream) {
  var definitions = schema['definitions'];
  if (!definitions || !Object.keys(definitions).length) {
    return console.log(chalk_1.default.yellowBright('There are v2 no definitions in schema'));
  }
  for (var definition in definitions) {
    writeType(writeStream, definition, definitions);
    console.log(
      ''
        .concat(chalk_1.default.greenBright('Type has been written'), ' - ')
        .concat(chalk_1.default.blueBright(definition)),
    );
  }
};
exports.parseV2types = parseV2types;
var parseV3types = function (schema, writeStream) {
  var _a;
  var componentsSchemas = (_a = schema.components) === null || _a === void 0 ? void 0 : _a.schemas;
  if (!componentsSchemas || !Object.keys(componentsSchemas).length) {
    return console.log(
      chalk_1.default.yellowBright('There are no v3 components.schemas in schema'),
    );
  }
  for (var componentsSchema in componentsSchemas) {
    writeType(writeStream, componentsSchema, componentsSchemas);
    console.log(
      ''
        .concat(chalk_1.default.greenBright('Type has been written'), ' - ')
        .concat(chalk_1.default.blueBright(componentsSchema)),
    );
  }
};
exports.parseV3types = parseV3types;
