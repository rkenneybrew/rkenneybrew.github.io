'use strict';

module.exports =
  ({ path, winston, winstonGoogle, config }) =>
  ({ labels = {}, logLevel = 'info' }) => {
    const { LOGGING_LEVELS } = config.LOGGER;
    const { ERROR_OPTIONS, COMBINED_OPTIONS } = config.LOGGER.TRANSPORTS.FILE;
    const { CLOUD_FUNCTION, CREDENTIALS } = config.GOOGLE;

    function loggingLevels() {
      return LOGGING_LEVELS.reduce((acc, cv, idx) => {
        acc[cv] = idx;
        return acc;
      }, {});
    }

    function loggerTransports() {
      const transports = [];
      if (config.NODE_ENV === 'production') {
        if (CLOUD_FUNCTION || CREDENTIALS) {
          transports.push(
            new winstonGoogle.LoggingWinston({
              labels,
              serviceContext: {
                service: labels.name,
                version: labels.version,
              },
            }),
          );
        } else {
          transports.push(new winston.transports.Console());
        }
      } else {
        transports.push(new winston.transports.Console());
        transports.push(new winston.transports.File(ERROR_OPTIONS));
        transports.push(new winston.transports.File(COMBINED_OPTIONS));
      }
      return transports;
    }

    function loggerFormat() {
      return winston.format.combine(winston.format.colorize(), winston.format.simple());
    }

    function createWrapper(logger) {
      function where(filePath, method, otherLabels = {}) {
        const file = path.basename(filePath);
        const childLogger = logger.child({
          labels: Object.assign({ file, method }, labels, otherLabels),
        });
        return createWrapper(childLogger);
      }
      function write(message) {
        logger.info(message);
      }
      return Object.assign(logger, { where, stream: { write } });
    }

    const loggerInstance = winston.createLogger({
      labels,
      level: logLevel,
      levels: loggingLevels(),
      format: loggerFormat(),
      transports: loggerTransports(),
    });

    return createWrapper(loggerInstance);
  };
