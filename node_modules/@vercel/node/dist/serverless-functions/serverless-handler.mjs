import { addHelpers } from './helpers.js';
import { createServer } from 'http';
import { serializeBody } from '../utils.js';
import { streamToBuffer } from '@vercel/build-utils';
import exitHook from 'exit-hook';
import fetch from 'node-fetch';
import { listen } from 'async-listen';
import { isAbsolute } from 'path';
import { pathToFileURL } from 'url';
async function createServerlessServer(userCode, options) {
    const server = createServer(async (req, res) => {
        if (options.shouldAddHelpers)
            await addHelpers(req, res);
        return userCode(req, res);
    });
    exitHook(() => server.close());
    return { url: await listen(server) };
}
async function compileUserCode(entrypointPath) {
    const id = isAbsolute(entrypointPath)
        ? pathToFileURL(entrypointPath).href
        : entrypointPath;
    let fn = await import(id);
    /**
     * In some cases we might have nested default props due to TS => JS
     */
    for (let i = 0; i < 5; i++) {
        if (fn.default)
            fn = fn.default;
    }
    return fn;
}
export async function createServerlessEventHandler(entrypointPath, options) {
    const userCode = await compileUserCode(entrypointPath);
    const server = await createServerlessServer(userCode, options);
    return async function (request) {
        const url = new URL(request.url ?? '/', server.url);
        // @ts-expect-error
        const response = await fetch(url, {
            body: await serializeBody(request),
            headers: {
                ...request.headers,
                host: request.headers['x-forwarded-host'],
            },
            method: request.method,
            redirect: 'manual',
        });
        let body;
        if (options.mode === 'streaming') {
            body = response.body;
        }
        else {
            body = await streamToBuffer(response.body);
            response.headers.delete('transfer-encoding');
            response.headers.set('content-length', body.length);
        }
        return {
            status: response.status,
            headers: response.headers,
            body,
            encoding: 'utf8',
        };
    };
}
